{"hash":"5f0f75c1eb53fb3ac5c6abb60be9489921ce10c9","fesm2022":[{"exports":["ListineVirtualScrollModule"],"facadeModuleId":"/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/listine.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/lib/listtine-virtual/variable-virtual-scroll/listine-virtual-scroll.component.mjs","/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/public-api.mjs","/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/listine.mjs"],"name":"listine","type":"chunk","dynamicImports":[],"fileName":"listine.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["EventEmitter","*","ElementRef","ViewChildren","ViewChild","Output","Input","ChangeDetectionStrategy","Component"],"@angular/common":["CommonModule","*"]},"imports":["@angular/core","@angular/common"],"modules":{"/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/lib/listtine-virtual/variable-virtual-scroll/listine-virtual-scroll.component.mjs":{"code":"/**\n * `s73-variable-virtual-scroll`\n *\n * A lightweight, customizable virtual scroll component that supports variable item heights.\n * Efficiently renders only visible items to improve performance for large lists.\n *\n * ## Inputs:\n * - `items`: List of data items to display\n * - `viewportHeight`: Height of the scrollable container (default: 400px)\n * - `buffer`: Number of extra items rendered above and below the viewport for smooth scrolling (default: 5)\n * - `itemTemplate`: Angular template for rendering each item\n * - `initialItemHeight`: Default item height before measurement (default: 50px)\n *\n * ## Outputs:\n * - `scrollEmitter`: Emits scroll position on every scroll event\n */\nclass ListineVirtualScrollModule {\n    cdr;\n    ngZone;\n    /** List of all items to render */\n    items = [];\n    /** Height of the scrollable viewport in pixels */\n    viewportHeight = 400;\n    /** Number of extra items to render above and below the viewport */\n    buffer = 5;\n    /** Template reference for rendering each item */\n    itemTemplate;\n    /** Initial estimated height of each item before actual measurement */\n    initialItemHeight = 50;\n    /** Emits scroll position whenever user scrolls */\n    scrollEmitter = new EventEmitter();\n    /** Reference to the scrolling container */\n    scrollerRef;\n    /** QueryList of rendered item elements (used for height measurement) */\n    itemElements;\n    /** Stores measured heights of items */\n    itemHeights = [];\n    /** Stores calculated top offset for each item */\n    itemTops = [];\n    /** Total height of all items (used to simulate full scrollable area) */\n    totalContentHeight = 0;\n    /** Index of the first visible item (including buffer) */\n    visibleStart = 0;\n    /** Index of the last visible item (including buffer) */\n    visibleEnd = 0;\n    /** Items currently visible in the viewport */\n    visibleItems = [];\n    /** ResizeObserver to watch for item height changes */\n    resizeObserver = new ResizeObserver(() => {\n        this.ngZone.run(() => {\n            this.measureItemHeights();\n        });\n    });\n    constructor(cdr, ngZone) {\n        this.cdr = cdr;\n        this.ngZone = ngZone;\n    }\n    /** Initialize item heights on component initialization */\n    ngOnInit() {\n        this.initializeHeights();\n        console.log(\"items \", this.items);\n    }\n    /**\n     * Respond to changes in input bindings (mainly the `items` array)\n     * @param changes - input property changes\n     */\n    ngOnChanges(changes) {\n        if (changes[\"items\"]) {\n            this.items = changes[\"items\"].currentValue;\n            this.initializeHeights();\n            setTimeout(() => {\n                this.calculateHeights();\n                this.onScroll();\n            });\n        }\n    }\n    /**\n     * Called after view initialization. Triggers initial height calculation.\n     */\n    ngAfterViewInit() {\n        setTimeout(() => {\n            this.calculateHeights();\n            this.onScroll();\n        });\n    }\n    /**\n     * Disconnects ResizeObserver on component destroy\n     */\n    ngOnDestroy() {\n        this.resizeObserver.disconnect();\n    }\n    /** Initializes item height and position tracking arrays */\n    initializeHeights() {\n        this.itemHeights = this.items.map(() => this.initialItemHeight);\n        this.updateItemTops();\n    }\n    /** Recalculates item top positions and content height */\n    calculateHeights() {\n        this.updateItemTops();\n    }\n    /** Updates top positions of all items based on their current heights */\n    updateItemTops() {\n        this.itemTops = [];\n        let top = 0;\n        for (const height of this.itemHeights) {\n            this.itemTops.push(top);\n            top += height;\n        }\n        this.totalContentHeight = top;\n    }\n    /**\n     * Returns the top position of an item by index\n     * @param index - index of the item\n     */\n    getItemTop(index) {\n        return this.itemTops[index] || 0;\n    }\n    /** Scroll event handler: calculates which items should be visible */\n    onScroll() {\n        const scrollTop = this.scrollerRef.nativeElement.scrollTop;\n        const viewportBottom = scrollTop + this.viewportHeight;\n        let start = 0;\n        while (start < this.items.length &&\n            this.getItemTop(start + 1) < scrollTop) {\n            start++;\n        }\n        let end = start;\n        while (end < this.items.length && this.getItemTop(end) < viewportBottom) {\n            end++;\n        }\n        this.visibleStart = Math.max(0, start - this.buffer);\n        this.visibleEnd = Math.min(this.items.length, end + this.buffer);\n        this.measureItemHeights();\n        this.updateVisibleItems();\n        this.scrollEmitter.emit(scrollTop);\n    }\n    /** Updates the list of items to be rendered based on scroll position */\n    updateVisibleItems() {\n        this.visibleItems = this.items.slice(this.visibleStart, this.visibleEnd);\n        // Wait for DOM render before measuring heights\n        setTimeout(() => {\n            this.measureItemHeights();\n        });\n    }\n    /** Measures actual heights of rendered DOM elements and updates tracking */\n    measureItemHeights() {\n        this.itemElements.forEach((el, idx) => {\n            const index = this.visibleStart + idx;\n            const height = el.nativeElement.offsetHeight;\n            if (this.itemHeights[index] !== height) {\n                this.itemHeights[index] = height;\n                this.resizeObserver.observe(el.nativeElement);\n            }\n        });\n        this.updateItemTops();\n        this.cdr.markForCheck();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.12\", ngImport: i0, type: ListineVirtualScrollModule, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.3.12\", type: ListineVirtualScrollModule, isStandalone: true, selector: \"listine-variable-virtual-scroll\", inputs: { items: \"items\", viewportHeight: \"viewportHeight\", buffer: \"buffer\", itemTemplate: \"itemTemplate\", initialItemHeight: \"initialItemHeight\" }, outputs: { scrollEmitter: \"scrollEmitter\" }, viewQueries: [{ propertyName: \"scrollerRef\", first: true, predicate: [\"scroller\"], descendants: true, static: true }, { propertyName: \"itemElements\", predicate: [\"itemElement\"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: \"<div\\n  #scroller\\n  class=\\\"scroll-container\\\"\\n  (scroll)=\\\"onScroll()\\\"\\n  [style.height.px]=\\\"viewportHeight\\\"\\n>\\n  <div class=\\\"total-height\\\" [style.height.px]=\\\"totalContentHeight\\\">\\n    <ng-container *ngFor=\\\"let item of visibleItems; let i = index\\\">\\n      <div\\n        #itemElement\\n        class=\\\"item\\\"\\n        [style.transform]=\\\"'translateY(' + getItemTop(visibleStart + i) + 'px)'\\\"\\n      >\\n        <ng-container\\n          *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\"\\n        ></ng-container>\\n      </div>\\n    </ng-container>\\n  </div>\\n</div>\\n\", styles: [\".scroll-container{overflow-y:auto;position:relative;width:100%;background:#fff}.total-height{position:relative;width:100%}.item{position:absolute;width:100%;box-sizing:border-box;will-change:transform}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"directive\", type: i1.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i1.NgTemplateOutlet, selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.12\", ngImport: i0, type: ListineVirtualScrollModule, decorators: [{\n            type: Component,\n            args: [{ selector: \"listine-variable-virtual-scroll\", standalone: true, imports: [CommonModule], changeDetection: ChangeDetectionStrategy.OnPush, template: \"<div\\n  #scroller\\n  class=\\\"scroll-container\\\"\\n  (scroll)=\\\"onScroll()\\\"\\n  [style.height.px]=\\\"viewportHeight\\\"\\n>\\n  <div class=\\\"total-height\\\" [style.height.px]=\\\"totalContentHeight\\\">\\n    <ng-container *ngFor=\\\"let item of visibleItems; let i = index\\\">\\n      <div\\n        #itemElement\\n        class=\\\"item\\\"\\n        [style.transform]=\\\"'translateY(' + getItemTop(visibleStart + i) + 'px)'\\\"\\n      >\\n        <ng-container\\n          *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\"\\n        ></ng-container>\\n      </div>\\n    </ng-container>\\n  </div>\\n</div>\\n\", styles: [\".scroll-container{overflow-y:auto;position:relative;width:100%;background:#fff}.total-height{position:relative;width:100%}.item{position:absolute;width:100%;box-sizing:border-box;will-change:transform}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }], propDecorators: { items: [{\n                type: Input\n            }], viewportHeight: [{\n                type: Input\n            }], buffer: [{\n                type: Input\n            }], itemTemplate: [{\n                type: Input\n            }], initialItemHeight: [{\n                type: Input\n            }], scrollEmitter: [{\n                type: Output\n            }], scrollerRef: [{\n                type: ViewChild,\n                args: [\"scroller\", { static: true }]\n            }], itemElements: [{\n                type: ViewChildren,\n                args: [\"itemElement\", { read: ElementRef }]\n            }] } });","originalLength":25143,"removedExports":[],"renderedExports":["ListineVirtualScrollModule"],"renderedLength":9538},"/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of Listine\n */","originalLength":635,"removedExports":[],"renderedExports":[],"renderedLength":39},"/Users/technous/Desktop/V:c/listine/dist/listine/esm2022/listine.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":484,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, ElementRef, ViewChildren, ViewChild, Output, Input, ChangeDetectionStrategy, Component } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * `s73-variable-virtual-scroll`\n *\n * A lightweight, customizable virtual scroll component that supports variable item heights.\n * Efficiently renders only visible items to improve performance for large lists.\n *\n * ## Inputs:\n * - `items`: List of data items to display\n * - `viewportHeight`: Height of the scrollable container (default: 400px)\n * - `buffer`: Number of extra items rendered above and below the viewport for smooth scrolling (default: 5)\n * - `itemTemplate`: Angular template for rendering each item\n * - `initialItemHeight`: Default item height before measurement (default: 50px)\n *\n * ## Outputs:\n * - `scrollEmitter`: Emits scroll position on every scroll event\n */\nclass ListineVirtualScrollModule {\n    cdr;\n    ngZone;\n    /** List of all items to render */\n    items = [];\n    /** Height of the scrollable viewport in pixels */\n    viewportHeight = 400;\n    /** Number of extra items to render above and below the viewport */\n    buffer = 5;\n    /** Template reference for rendering each item */\n    itemTemplate;\n    /** Initial estimated height of each item before actual measurement */\n    initialItemHeight = 50;\n    /** Emits scroll position whenever user scrolls */\n    scrollEmitter = new EventEmitter();\n    /** Reference to the scrolling container */\n    scrollerRef;\n    /** QueryList of rendered item elements (used for height measurement) */\n    itemElements;\n    /** Stores measured heights of items */\n    itemHeights = [];\n    /** Stores calculated top offset for each item */\n    itemTops = [];\n    /** Total height of all items (used to simulate full scrollable area) */\n    totalContentHeight = 0;\n    /** Index of the first visible item (including buffer) */\n    visibleStart = 0;\n    /** Index of the last visible item (including buffer) */\n    visibleEnd = 0;\n    /** Items currently visible in the viewport */\n    visibleItems = [];\n    /** ResizeObserver to watch for item height changes */\n    resizeObserver = new ResizeObserver(() => {\n        this.ngZone.run(() => {\n            this.measureItemHeights();\n        });\n    });\n    constructor(cdr, ngZone) {\n        this.cdr = cdr;\n        this.ngZone = ngZone;\n    }\n    /** Initialize item heights on component initialization */\n    ngOnInit() {\n        this.initializeHeights();\n        console.log(\"items \", this.items);\n    }\n    /**\n     * Respond to changes in input bindings (mainly the `items` array)\n     * @param changes - input property changes\n     */\n    ngOnChanges(changes) {\n        if (changes[\"items\"]) {\n            this.items = changes[\"items\"].currentValue;\n            this.initializeHeights();\n            setTimeout(() => {\n                this.calculateHeights();\n                this.onScroll();\n            });\n        }\n    }\n    /**\n     * Called after view initialization. Triggers initial height calculation.\n     */\n    ngAfterViewInit() {\n        setTimeout(() => {\n            this.calculateHeights();\n            this.onScroll();\n        });\n    }\n    /**\n     * Disconnects ResizeObserver on component destroy\n     */\n    ngOnDestroy() {\n        this.resizeObserver.disconnect();\n    }\n    /** Initializes item height and position tracking arrays */\n    initializeHeights() {\n        this.itemHeights = this.items.map(() => this.initialItemHeight);\n        this.updateItemTops();\n    }\n    /** Recalculates item top positions and content height */\n    calculateHeights() {\n        this.updateItemTops();\n    }\n    /** Updates top positions of all items based on their current heights */\n    updateItemTops() {\n        this.itemTops = [];\n        let top = 0;\n        for (const height of this.itemHeights) {\n            this.itemTops.push(top);\n            top += height;\n        }\n        this.totalContentHeight = top;\n    }\n    /**\n     * Returns the top position of an item by index\n     * @param index - index of the item\n     */\n    getItemTop(index) {\n        return this.itemTops[index] || 0;\n    }\n    /** Scroll event handler: calculates which items should be visible */\n    onScroll() {\n        const scrollTop = this.scrollerRef.nativeElement.scrollTop;\n        const viewportBottom = scrollTop + this.viewportHeight;\n        let start = 0;\n        while (start < this.items.length &&\n            this.getItemTop(start + 1) < scrollTop) {\n            start++;\n        }\n        let end = start;\n        while (end < this.items.length && this.getItemTop(end) < viewportBottom) {\n            end++;\n        }\n        this.visibleStart = Math.max(0, start - this.buffer);\n        this.visibleEnd = Math.min(this.items.length, end + this.buffer);\n        this.measureItemHeights();\n        this.updateVisibleItems();\n        this.scrollEmitter.emit(scrollTop);\n    }\n    /** Updates the list of items to be rendered based on scroll position */\n    updateVisibleItems() {\n        this.visibleItems = this.items.slice(this.visibleStart, this.visibleEnd);\n        // Wait for DOM render before measuring heights\n        setTimeout(() => {\n            this.measureItemHeights();\n        });\n    }\n    /** Measures actual heights of rendered DOM elements and updates tracking */\n    measureItemHeights() {\n        this.itemElements.forEach((el, idx) => {\n            const index = this.visibleStart + idx;\n            const height = el.nativeElement.offsetHeight;\n            if (this.itemHeights[index] !== height) {\n                this.itemHeights[index] = height;\n                this.resizeObserver.observe(el.nativeElement);\n            }\n        });\n        this.updateItemTops();\n        this.cdr.markForCheck();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.3.12\", ngImport: i0, type: ListineVirtualScrollModule, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"17.3.12\", type: ListineVirtualScrollModule, isStandalone: true, selector: \"listine-variable-virtual-scroll\", inputs: { items: \"items\", viewportHeight: \"viewportHeight\", buffer: \"buffer\", itemTemplate: \"itemTemplate\", initialItemHeight: \"initialItemHeight\" }, outputs: { scrollEmitter: \"scrollEmitter\" }, viewQueries: [{ propertyName: \"scrollerRef\", first: true, predicate: [\"scroller\"], descendants: true, static: true }, { propertyName: \"itemElements\", predicate: [\"itemElement\"], descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: \"<div\\n  #scroller\\n  class=\\\"scroll-container\\\"\\n  (scroll)=\\\"onScroll()\\\"\\n  [style.height.px]=\\\"viewportHeight\\\"\\n>\\n  <div class=\\\"total-height\\\" [style.height.px]=\\\"totalContentHeight\\\">\\n    <ng-container *ngFor=\\\"let item of visibleItems; let i = index\\\">\\n      <div\\n        #itemElement\\n        class=\\\"item\\\"\\n        [style.transform]=\\\"'translateY(' + getItemTop(visibleStart + i) + 'px)'\\\"\\n      >\\n        <ng-container\\n          *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\"\\n        ></ng-container>\\n      </div>\\n    </ng-container>\\n  </div>\\n</div>\\n\", styles: [\".scroll-container{overflow-y:auto;position:relative;width:100%;background:#fff}.total-height{position:relative;width:100%}.item{position:absolute;width:100%;box-sizing:border-box;will-change:transform}\\n\"], dependencies: [{ kind: \"ngmodule\", type: CommonModule }, { kind: \"directive\", type: i1.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { kind: \"directive\", type: i1.NgTemplateOutlet, selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\", \"ngTemplateOutletInjector\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.3.12\", ngImport: i0, type: ListineVirtualScrollModule, decorators: [{\n            type: Component,\n            args: [{ selector: \"listine-variable-virtual-scroll\", standalone: true, imports: [CommonModule], changeDetection: ChangeDetectionStrategy.OnPush, template: \"<div\\n  #scroller\\n  class=\\\"scroll-container\\\"\\n  (scroll)=\\\"onScroll()\\\"\\n  [style.height.px]=\\\"viewportHeight\\\"\\n>\\n  <div class=\\\"total-height\\\" [style.height.px]=\\\"totalContentHeight\\\">\\n    <ng-container *ngFor=\\\"let item of visibleItems; let i = index\\\">\\n      <div\\n        #itemElement\\n        class=\\\"item\\\"\\n        [style.transform]=\\\"'translateY(' + getItemTop(visibleStart + i) + 'px)'\\\"\\n      >\\n        <ng-container\\n          *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\"\\n        ></ng-container>\\n      </div>\\n    </ng-container>\\n  </div>\\n</div>\\n\", styles: [\".scroll-container{overflow-y:auto;position:relative;width:100%;background:#fff}.total-height{position:relative;width:100%}.item{position:absolute;width:100%;box-sizing:border-box;will-change:transform}\\n\"] }]\n        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }], propDecorators: { items: [{\n                type: Input\n            }], viewportHeight: [{\n                type: Input\n            }], buffer: [{\n                type: Input\n            }], itemTemplate: [{\n                type: Input\n            }], initialItemHeight: [{\n                type: Input\n            }], scrollEmitter: [{\n                type: Output\n            }], scrollerRef: [{\n                type: ViewChild,\n                args: [\"scroller\", { static: true }]\n            }], itemElements: [{\n                type: ViewChildren,\n                args: [\"itemElement\", { read: ElementRef }]\n            }] } });\n\n/*\n * Public API Surface of Listine\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ListineVirtualScrollModule };\n//# sourceMappingURL=listine.mjs.map\n","map":null,"preliminaryFileName":"listine.mjs","sourcemapFileName":"listine.mjs.map"},{"fileName":"listine.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"listine.mjs\",\"sources\":[\"../../../projects/listine/src/lib/listtine-virtual/variable-virtual-scroll/listine-virtual-scroll.component.ts\",\"../../../projects/listine/src/lib/listtine-virtual/variable-virtual-scroll/listine-virtual-scroll.component.html\",\"../../../projects/listine/src/public-api.ts\",\"../../../projects/listine/src/listine.ts\"],\"sourcesContent\":[\"import {\\n  Component,\\n  Input,\\n  TemplateRef,\\n  ViewChild,\\n  ElementRef,\\n  AfterViewInit,\\n  ChangeDetectionStrategy,\\n  ChangeDetectorRef,\\n  ViewChildren,\\n  QueryList,\\n  EventEmitter,\\n  Output,\\n  OnChanges,\\n  SimpleChanges,\\n  OnInit,\\n  OnDestroy,\\n  NgZone,\\n} from \\\"@angular/core\\\";\\nimport { CommonModule } from \\\"@angular/common\\\";\\n\\n/**\\n * `s73-variable-virtual-scroll`\\n *\\n * A lightweight, customizable virtual scroll component that supports variable item heights.\\n * Efficiently renders only visible items to improve performance for large lists.\\n *\\n * ## Inputs:\\n * - `items`: List of data items to display\\n * - `viewportHeight`: Height of the scrollable container (default: 400px)\\n * - `buffer`: Number of extra items rendered above and below the viewport for smooth scrolling (default: 5)\\n * - `itemTemplate`: Angular template for rendering each item\\n * - `initialItemHeight`: Default item height before measurement (default: 50px)\\n *\\n * ## Outputs:\\n * - `scrollEmitter`: Emits scroll position on every scroll event\\n */\\n@Component({\\n  selector: \\\"listine-variable-virtual-scroll\\\",\\n  standalone: true,\\n  imports: [CommonModule],\\n  templateUrl: \\\"./listine-virtual-scroll.component.html\\\",\\n  styleUrls: [\\\"./listine-virtual-scroll.component.scss\\\"],\\n  changeDetection: ChangeDetectionStrategy.OnPush,\\n})\\nexport class ListineVirtualScrollModule\\n  implements OnInit, AfterViewInit, OnChanges, OnDestroy\\n{\\n  /** List of all items to render */\\n  @Input() items: any[] = [];\\n\\n  /** Height of the scrollable viewport in pixels */\\n  @Input() viewportHeight = 400;\\n\\n  /** Number of extra items to render above and below the viewport */\\n  @Input() buffer = 5;\\n\\n  /** Template reference for rendering each item */\\n  @Input() itemTemplate: TemplateRef<any>;\\n\\n  /** Initial estimated height of each item before actual measurement */\\n  @Input() initialItemHeight = 50;\\n\\n  /** Emits scroll position whenever user scrolls */\\n  @Output() scrollEmitter = new EventEmitter<any>();\\n\\n  /** Reference to the scrolling container */\\n  @ViewChild(\\\"scroller\\\", { static: true }) scrollerRef!: ElementRef;\\n\\n  /** QueryList of rendered item elements (used for height measurement) */\\n  @ViewChildren(\\\"itemElement\\\", { read: ElementRef })\\n  itemElements!: QueryList<ElementRef>;\\n\\n  /** Stores measured heights of items */\\n  itemHeights: number[] = [];\\n\\n  /** Stores calculated top offset for each item */\\n  itemTops: number[] = [];\\n\\n  /** Total height of all items (used to simulate full scrollable area) */\\n  totalContentHeight = 0;\\n\\n  /** Index of the first visible item (including buffer) */\\n  visibleStart = 0;\\n\\n  /** Index of the last visible item (including buffer) */\\n  visibleEnd = 0;\\n\\n  /** Items currently visible in the viewport */\\n  visibleItems: any[] = [];\\n\\n  /** ResizeObserver to watch for item height changes */\\n  private resizeObserver = new ResizeObserver(() => {\\n    this.ngZone.run(() => {\\n      this.measureItemHeights();\\n    });\\n  });\\n\\n  constructor(private cdr: ChangeDetectorRef, private ngZone: NgZone) {}\\n\\n  /** Initialize item heights on component initialization */\\n  ngOnInit(): void {\\n    this.initializeHeights();\\n    console.log(\\\"items \\\", this.items);\\n  }\\n\\n  /**\\n   * Respond to changes in input bindings (mainly the `items` array)\\n   * @param changes - input property changes\\n   */\\n  ngOnChanges(changes: SimpleChanges): void {\\n    if (changes[\\\"items\\\"]) {\\n      this.items = changes[\\\"items\\\"].currentValue;\\n      this.initializeHeights();\\n\\n      setTimeout(() => {\\n        this.calculateHeights();\\n        this.onScroll();\\n      });\\n    }\\n  }\\n\\n  /**\\n   * Called after view initialization. Triggers initial height calculation.\\n   */\\n  ngAfterViewInit() {\\n    setTimeout(() => {\\n      this.calculateHeights();\\n      this.onScroll();\\n    });\\n  }\\n\\n  /**\\n   * Disconnects ResizeObserver on component destroy\\n   */\\n  ngOnDestroy(): void {\\n    this.resizeObserver.disconnect();\\n  }\\n\\n  /** Initializes item height and position tracking arrays */\\n  initializeHeights() {\\n    this.itemHeights = this.items.map(() => this.initialItemHeight);\\n    this.updateItemTops();\\n  }\\n\\n  /** Recalculates item top positions and content height */\\n  calculateHeights() {\\n    this.updateItemTops();\\n  }\\n\\n  /** Updates top positions of all items based on their current heights */\\n  updateItemTops() {\\n    this.itemTops = [];\\n    let top = 0;\\n    for (const height of this.itemHeights) {\\n      this.itemTops.push(top);\\n      top += height;\\n    }\\n    this.totalContentHeight = top;\\n  }\\n\\n  /**\\n   * Returns the top position of an item by index\\n   * @param index - index of the item\\n   */\\n  getItemTop(index: number): number {\\n    return this.itemTops[index] || 0;\\n  }\\n\\n  /** Scroll event handler: calculates which items should be visible */\\n  onScroll() {\\n    const scrollTop = this.scrollerRef.nativeElement.scrollTop;\\n    const viewportBottom = scrollTop + this.viewportHeight;\\n\\n    let start = 0;\\n    while (\\n      start < this.items.length &&\\n      this.getItemTop(start + 1) < scrollTop\\n    ) {\\n      start++;\\n    }\\n\\n    let end = start;\\n    while (end < this.items.length && this.getItemTop(end) < viewportBottom) {\\n      end++;\\n    }\\n\\n    this.visibleStart = Math.max(0, start - this.buffer);\\n    this.visibleEnd = Math.min(this.items.length, end + this.buffer);\\n    this.measureItemHeights();\\n    this.updateVisibleItems();\\n\\n    this.scrollEmitter.emit(scrollTop);\\n  }\\n\\n  /** Updates the list of items to be rendered based on scroll position */\\n  updateVisibleItems() {\\n    this.visibleItems = this.items.slice(this.visibleStart, this.visibleEnd);\\n\\n    // Wait for DOM render before measuring heights\\n    setTimeout(() => {\\n      this.measureItemHeights();\\n    });\\n  }\\n\\n  /** Measures actual heights of rendered DOM elements and updates tracking */\\n  measureItemHeights() {\\n    this.itemElements.forEach((el, idx) => {\\n      const index = this.visibleStart + idx;\\n      const height = el.nativeElement.offsetHeight;\\n      if (this.itemHeights[index] !== height) {\\n        this.itemHeights[index] = height;\\n        this.resizeObserver.observe(el.nativeElement);\\n      }\\n    });\\n    this.updateItemTops();\\n    this.cdr.markForCheck();\\n  }\\n}\\n\",\"<div\\n  #scroller\\n  class=\\\"scroll-container\\\"\\n  (scroll)=\\\"onScroll()\\\"\\n  [style.height.px]=\\\"viewportHeight\\\"\\n>\\n  <div class=\\\"total-height\\\" [style.height.px]=\\\"totalContentHeight\\\">\\n    <ng-container *ngFor=\\\"let item of visibleItems; let i = index\\\">\\n      <div\\n        #itemElement\\n        class=\\\"item\\\"\\n        [style.transform]=\\\"'translateY(' + getItemTop(visibleStart + i) + 'px)'\\\"\\n      >\\n        <ng-container\\n          *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\"\\n        ></ng-container>\\n      </div>\\n    </ng-container>\\n  </div>\\n</div>\\n\",\"/*\\n * Public API Surface of Listine\\n */\\n\\nexport * from \\\"./lib/listtine-virtual/variable-virtual-scroll/listine-virtual-scroll.component\\\";\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}